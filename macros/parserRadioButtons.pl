loadMacros('Parser.pl','contextString.pl');

sub _parserRadioButtons_init {}; # don't reload this file

####################################################################
#
#  This file implements a radio button group object that is compatible
#  with Value objects, and in particular, with the MultiPart object.
#
#  To create a RadioButtons object, use
#
#    $radio = RadioButtons([choices,...],correct,options);
#
#  where "choices" are the strings for the items in the radio buttons,
#  "correct" is the choice that is the correct answer for the group,
#  and options are chosen from among:
#
#     labels => [label1,...]     Specifies the text to be used
#                                as the student answer for each
#                                entry in the radio group.
#                                This can also be set to the string
#                                "ABC" to get lettered labels or
#                                "123" to get numbered labels.
#                                The default is to use a few words
#                                from the text string for each button.
#
#     separator => string        text to put between the radio
#                                buttons.
#                                  Default: $BR
#
#     checked => choice          the text or index (starting at zero)
#                                of the button to be checked
#                                  Default: none checked
#
#     maxLabelSize => n          the approximate largest size that should
#                                be used for the answer strings to be
#                                generated by the radio buttons (if
#                                the choice strings are too long, they
#                                will be trimmed and "..." inserted)
#                                  Default: 25
#
#
#  To insert the radio buttons into the problem text, use
#
#    BEGIN_TEXT
#      \{$radio->buttons\}
#    END_TEXT
#
#  and then
#
#    ANS($radio->cmp);
#
#  to get the answer checker for the radion buttons.
#
#  You can use the RadioButtons object in MultiPart objects.  This is
#  the reason for the RadioButton's ans_rule method (since that is what
#  MultiPart calls to get answer rules).
#

sub RadioButtons {parserRadioButtons->new(@_)}

#
#  The package that implements RadioButtons
#
package parserRadioButtons;
our @ISA = qw(Value::String);


#
#  Create a new RadioButtons object
#
sub new {
  my $self = shift; my $class = ref($self) || $self;
  my $choices = shift; my $value = shift;
  my %options;
  main::set_default_options(\%options,
    labels => [],
    separator => $main::BR,
    checked => undef,
    maxLabelSize => 25,
    @_,
  );
  $options{labels} = [1..scalar(@$choices)] if $options{labels} eq "123";
  $options{labels} = [@main::ALPHABET[0..scalar(@$choices)-1]] if $options{labels} eq "ABC";
  my $self = bless {%options, choices=>$choices}, $class; # temporary to so we can call our methods
  Value::Error("A RadioButton's first argument should be a list of button labels")
    unless ref($choices) eq 'ARRAY';
  Value::Error("A RadioButton's second argument should be the correct button choice")
    unless defined($value) && $value ne "";
  my $oldContext = main::Context();
  my $context = $main::context{String}->copy;
  main::Context($context);
  my %choiceHash = $self->choiceHash(1);
  $context->strings->add(map {$_=>{}} (keys %choiceHash));
  $value = $self->correctChoice($value);
  $self = bless Value::String->new($value)->with(
    isValue => 1, context => $context,
    choices => $choices,
    %options,
  ), $class;
  main::Context($oldContext);
  return $self;
}

#
#  Locate the label of the correct answer
#  The answer can be given as an index, as the full answer
#    or as the label itself.
#
sub correctChoice {
  my $self = shift; my $value = shift;
  my $index = $self->Index($value);
  foreach my $i (0..scalar(@{$self->{choices}})-1) {
    my $label = $self->{labels}[$i]; my $choice = $self->{choices}[$i];
    $label = $self->makeLabel($choice) unless defined $label;
    return $label if $label eq $value || $index == $i || $choice eq $value;
  }
  Value::Error("The correct answer should be one of the button choices");
}

#
#  Create the hash of label => answer pairs to be used for the
#  ans_radio_buttons() routine
#
sub choiceHash {
  my $self = shift; my $noChecked = shift;
  my @radio = ();
  my $index = $self->Index($self->{checked});
  my $checked = $self->{checked}; $checked = "" unless defined $checked;
  if ($noChecked) {$checked = ""; $index = -1}
  foreach my $i (0..scalar(@{$self->{choices}})-1) {
    my $label = $self->{labels}[$i]; my $choice = $self->{choices}[$i];
    $label = $self->makeLabel($choice) unless defined $label;
    $label = "%$label" if $label eq $checked || $index == $i || $choice eq $checked;
    push(@radio, $label,$choice);
  }
  return @radio;
}

#
#  Create a label for the answer, either using the labels
#  provided by the user, or by creating one from the answer
#  string (restrict its length so that the results table
#  will not be overflowed).
#
sub makeLabel {
  my $self = shift; my $choice = shift;
  return $choice if length($choice) < $self->{maxLabelSize};
  my @words = split(/\b/,$choice);
  my ($s,$e) = ('','');
  do {$s .= shift(@words); $e = pop(@words) . $e}
    while length($s) + length($e) + 15 < $self->{maxLabelSize} && scalar(@words);
  return $s . " ... " . $e;
}

#
#  Get a numeric index (-1 if not defined or not a number)
#
sub Index {
  my $self = shift; my $index = shift;
  return -1 unless defined $index && $index =~ m/^\d$/;
  return $index;
}

#
#  Create the radio-buttons text
#
sub buttons {
  my $self = shift;
  my @radio = main::ans_radio_buttons($self->choiceHash);
  (wantarray) ? @radio : join($self->{separator}, @radio);
}
sub named_buttons {
  my $self = shift; my $name = shift;
  my @radio = NAMED_ANS_RADIO_BUTTONS($name,$self->choiceHash);
  #
  #  Taken from PGbasicmacros.pl
  #  It is wrong to have \item in the radio buttons and to add itemize here,
  #    but that is the way PGbasicmacros.pl does it.
  #
  if ($displayMode eq 'TeX') {
    $radio[0] = "\n\\begin{itemize}\n" . $radio[0];
    $radio[$#radio_buttons] .= "\n\\end{itemize}\n";
  }
  (wantarray) ? @radio: join($self->{separator}, @radio);
}

sub ans_rule {shift->buttons(@_)}
sub named_ans_rule {shift->named_buttons(@_)}

1;
