loadMacros('Parser.pl','contextString.pl');

sub _parserRadioButtons_init {}; # don't reload this file

=head1 DESCRIPTION

####################################################################
#
#  This file implements a radio button group object that is compatible
#  with Value objects, and in particular, with the MultiPart object.
#
#  To create a RadioButtons object, use
#
#    $radio = RadioButtons([choices,...],correct,options);
#
#  where "choices" are the strings for the items in the radio buttons,
#  "correct" is the choice that is the correct answer for the group,
#  and options are chosen from among:
#
#     labels => [label1,...]     Specifies the text to be used
#                                as the student answer for each
#                                entry in the radio group.
#                                This can also be set to the string
#                                "ABC" to get lettered labels or
#                                "123" to get numbered labels.
#                                The default is to use a few words
#                                from the text string for each button.
#
#     separator => string        text to put between the radio
#                                buttons.
#                                  Default: $BR
#
#     checked => choice          the text or index (starting at zero)
#                                of the button to be checked
#                                  Default: none checked
#
#     maxLabelSize => n          the approximate largest size that should
#                                be used for the answer strings to be
#                                generated by the radio buttons (if
#                                the choice strings are too long, they
#                                will be trimmed and "..." inserted)
#                                  Default: 25
#
#     uncheckable => 0 or 1      determines whether the radio buttons can
#                    or "shift"  be unchecked (requires JavaScript).
#                                To uncheck, click a second time; when
#                                set to "shift", unchecking requires the
#                                shift key to be pressed.
#                                  Default: 0
#
#
#  To insert the radio buttons into the problem text, use
#
#    BEGIN_TEXT
#      \{$radio->buttons\}
#    END_TEXT
#
#  and then
#
#    ANS($radio->cmp);
#
#  to get the answer checker for the radion buttons.
#
#  You can use the RadioButtons object in MultiPart objects.  This is
#  the reason for the RadioButton's ans_rule method (since that is what
#  MultiPart calls to get answer rules).
#

=cut

sub RadioButtons {parserRadioButtons->new(@_)}

#
#  The package that implements RadioButtons
#
package parserRadioButtons;
our @ISA = qw(Value::String);

my $jsPrinted = 0;  # true when the JavaScript has been printed


#
#  Create a new RadioButtons object
#
sub new {
  my $self = shift; my $class = ref($self) || $self;
  my $context = (Value::isContext($_[0]) ? shift : $self->context);
  my $choices = shift; my $value = shift;
  my %options;
  main::set_default_options(\%options,
    labels => [],
    separator => $main::BR,
    checked => undef,
    maxLabelSize => 25,
    uncheckable => 0,
    @_,
  );
  $options{labels} = [1..scalar(@$choices)] if $options{labels} eq "123";
  $options{labels} = [@main::ALPHABET[0..scalar(@$choices)-1]] if $options{labels} eq "ABC";
  my $self = bless {%options, choices=>$choices}, $class; # temporary to so we can call our methods
  Value::Error("A RadioButton's first argument should be a list of button labels")
    unless ref($choices) eq 'ARRAY';
  Value::Error("A RadioButton's second argument should be the correct button choice")
    unless defined($value) && $value ne "";
  my $context = Parser::Context->getCopy("String");
  my %choiceHash = $self->choiceHash(1);
  $context->strings->add(map {$_=>{}} (keys %choiceHash));
  $value = $self->correctChoice($value);
  $self = bless $context->Package("String")->new($context,$value)->with(
    isValue => 1, choices => $choices, %options), $class;
  $self->JavaScript if $self->{uncheckable};
  return $self;
}

#
#  Locate the label of the correct answer
#  The answer can be given as an index, as the full answer
#    or as the label itself.
#
sub correctChoice {
  my $self = shift; my $value = shift;
  my $index = $self->Index($value);
  foreach my $i (0..scalar(@{$self->{choices}})-1) {
    my $label = $self->{labels}[$i]; my $choice = $self->{choices}[$i];
    $label = $self->makeLabel($choice) unless defined $label;
    return $label if $label eq $value || $index == $i || $choice eq $value;
  }
  Value::Error("The correct answer should be one of the button choices");
}

#
#  Create the hash of label => answer pairs to be used for the
#  ans_radio_buttons() routine
#
sub choiceHash {
  my $self = shift; my $noChecked = shift;
  my @radio = ();
  my $index = $self->Index($self->{checked});
  my $checked = $self->{checked}; $checked = "" unless defined $checked;
  if ($noChecked) {$checked = ""; $index = -1}
  foreach my $i (0..scalar(@{$self->{choices}})-1) {
    my $label = $self->{labels}[$i]; my $choice = $self->{choices}[$i];
    $label = $self->makeLabel($choice) unless defined $label;
    $label = "%$label" if $label eq $checked || $index == $i || $choice eq $checked;
    push(@radio, $label,$choice);
  }
  return @radio;
}

#
#  Create a label for the answer, either using the labels
#  provided by the user, or by creating one from the answer
#  string (restrict its length so that the results table
#  will not be overflowed).
#
sub makeLabel {
  my $self = shift; my $choice = shift;
  return $choice if length($choice) < $self->{maxLabelSize};
  my @words = split(/\b/,$choice);
  my ($s,$e) = ('','');
  do {$s .= shift(@words); $e = pop(@words) . $e}
    while length($s) + length($e) + 15 < $self->{maxLabelSize} && scalar(@words);
  return $s . " ... " . $e;
}

#
#  Get a numeric index (-1 if not defined or not a number)
#
sub Index {
  my $self = shift; my $index = shift;
  return -1 unless defined $index && $index =~ m/^\d$/;
  return $index;
}

#
#  Print the JavaScript needed for uncheckable radio buttons
#
sub JavaScript {
  return if $main::displayMode eq 'TeX';
  return if $jsPrinted;
  main::TEXT(
    "\n<script>\n" .
    "if (window.ww == null) {var ww = {}}\n" .
    "if (ww.RadioButtons == null) {ww.RadioButtons = {}}\n" .
    "if (ww.RadioButtons.selected == null) {ww.RadioButtons.selected = {}}\n" .
    "ww.RadioButtons.Toggle = function (obj,event,shift) {\n" .
    "  if (!event) {event = window.event}\n" .
    "  if (shift && !event.shiftKey) {\n" .
    "    this.selected[obj.name] = obj\n" .
    "    return\n" .
    "  }\n" .
    "  var selected = this.selected[obj.name]\n" .
    "  if (selected && selected == obj) {\n".
    "    this.selected[obj.name] = null\n" .
    "    obj.checked = false\n" .
    "  } else {\n" .
    "    this.selected[obj.name] = obj\n".
    "  }\n" .
    "}\n".
    "</script>\n"
  );
  $jsSPrinted = 1;
}

sub makeUncheckable {
  my $self = shift;
  my $shift = ($self->{uncheckable} =~ m/shift/i ? ",1" : "");
  my $onclick = "onclick=\"ww.RadioButtons.Toggle(this,event$shift)\"";
  my @radio = @_;
  foreach (@radio) {$_ =~ s/<INPUT/<INPUT $onclick/i}
  return @radio;
}

#
#  Create the radio-buttons text
#
sub buttons {
  my $self = shift;
  my @radio = main::ans_radio_buttons($self->choiceHash);
  @radio = $self->makeUncheckable(@radio) if $self->{uncheckable};
  (wantarray) ? @radio : join($self->{separator}, @radio);
}
sub named_buttons {
  my $self = shift; my $name = shift;
  my @radio = NAMED_ANS_RADIO_BUTTONS($name,$self->choiceHash);
  @radio = $self->makeUncheckable(@radio) if $self->{uncheckable};
  #
  #  Taken from PGbasicmacros.pl
  #  It is wrong to have \item in the radio buttons and to add itemize here,
  #    but that is the way PGbasicmacros.pl does it.
  #
  if ($displayMode eq 'TeX') {
    $radio[0] = "\n\\begin{itemize}\n" . $radio[0];
    $radio[$#radio_buttons] .= "\n\\end{itemize}\n";
  }
  (wantarray) ? @radio: join($self->{separator}, @radio);
}

sub ans_rule {shift->buttons(@_)}
sub named_ans_rule {shift->named_buttons(@_)}

1;
